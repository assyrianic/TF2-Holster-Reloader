//generated by Ubuntu 14.04 gedit

#include <sourcemod>
#include <tf2_stocks>
#include <sdkhooks>

#pragma semicolon		1
#pragma newdecls		required

#define PLUGIN_VERSION		"1.0"

//Python-style comparison operators =)

#define and		&&
#define and_eq		&=
#define bitand		&
#define bitor		|
#define compl		~
#define not		!
#define not_eq		!=
#define or		||
#define or_eq		|=
#define xor		^
#define xor_eq		^=
#define eq		==

#define KULEH			MAXPLAYERS+1
#define IsClientValid(%1)	( 0 < %1 and %1 <= MaxClients )

#define PATH			64
#define URKHA			PLATFORM_MAX_PATH

public Plugin myinfo = { //registers plugin
	name = "holster reload",
	author = "Nergal/Assyrian/Ashurian/Asuri/ܫܘܪܝܐ",
	description = "holster reload plugin allows players to reload holstered weapons after a certain period of time",
	version = PLUGIN_VERSION,
	url = "HL2.exe",
};
char strSound[ PATH ];
float flDviqa[ KULEH ][ 3 ]; //amount of time the player holstered the slot away

any LazyGlobal[ 10 ][ 3 ]; //the ultimate form of laziness

int AmmoTable[ 2049 ]; //get the max ammo of the weapon
int ClipTable[ 2049 ]; //get the max clip of weapon
bool bChatSpam[ KULEH ];

ConVar cvPluginEnabled = null;
ConVar cvAllowBlu = null;
ConVar cvAllowRed = null;
ConVar cvSound = null;

public void OnPluginStart()
{
	cvPluginEnabled = CreateConVar("holsterreload_enabled", "1", "Enable the Holster Reload plugin", FCVAR_PLUGIN, true, 0.0, true, 1.0);
	cvAllowBlu = CreateConVar("holsterreload_blu", "1", "allow holster reloading for blue team", FCVAR_PLUGIN|FCVAR_NOTIFY, true, 0.0, true, 1.0);

	cvAllowRed = CreateConVar("holsterreload_red", "1", "allow holster reloading for red team", FCVAR_PLUGIN|FCVAR_NOTIFY, true, 0.0, true, 1.0);

	cvSound = CreateConVar("holsterreload_reloadsound", "ui/item_store_add_to_cart.wav", "the reloading sound that notifies players that their inactive weapon has been reloaded", FCVAR_PLUGIN);

	AutoExecConfig(true, "Holster-Reload");

	RegAdminCmd("sm_holster", CommandTemplate, ADMFLAG_SLAY, "Admin Weapon Alpha");
	RegAdminCmd("sm_reholster", CommandReload, ADMFLAG_SLAY, "Admin Weapon Alpha");

	for (int i = 1; i <= MaxClients; i++)
	{
		if ( not IsValidClient(i) ) { continue; }
		OnClientPutInServer(i);
	}
	cvSound.GetString( strSound, sizeof(strSound) );
	PrecacheSound(strSound, true);
	SetupKeyValues();
}

public void OnClientPutInServer(int client)
{
	SDKHook(client, SDKHook_PostThink, OnPostThink);
	SDKHook(client, SDKHook_WeaponSwitchPost, OnWeaponSwitchPost);
}

public void OnPostThink(int client)
{
	if ( not cvPluginEnabled.BoolValue ) return;
	if ( (not cvAllowBlu.BoolValue && (GetClientTeam(client) == 3)) || (not cvAllowRed.BoolValue && (GetClientTeam(client) == 2)) )
		return;

	int cls = view_as<int>( TF2_GetPlayerClass(client) );
	for (int i = 0; i < 2; i++)
	{
		int wep = GetPlayerWeaponSlot(client, i);
		if ( wep <= 0 ) {continue;}
		if ( wep eq GetActiveWeap(client) ) {continue;}

		BackPackReload( EntIndexToEntRef(wep), flDviqa[client][i], LazyGlobal[cls][0], view_as<bool>(LazyGlobal[cls][1]), LazyGlobal[cls][2] );

		if (bChatSpam[client]) {
			PrintToConsole(client, "classnum = %i, dviqa = %f, reloadtime = %f, singlereload = %i, interval = %i", cls, flDviqa[client][i], LazyGlobal[cls][0], LazyGlobal[cls][1], LazyGlobal[cls][2]);
		}
	}
	return;
}

public void OnEntityCreated(int entity, const char[] classname)
{
	if ( not cvPluginEnabled.BoolValue ) {return;}
	if ( StrContains(classname, "tf_weapon_") not_eq -1 and IsValidEntity(entity) ) {
		CreateTimer( 0.55, OnWeaponSpawned, EntIndexToEntRef(entity) );
	}
	return;
}

public Action OnWeaponSpawned(Handle timer, any ref)
{
	int wep = EntRefToEntIndex(ref);
	if ( IsValidEntity(wep) and IsValidEdict(wep) ) {
		char name[32]; GetEntityClassname(wep, name, sizeof(name));
		if ( StrContains(name, "tf_weap", false) not_eq -1 ) {
			int client = GetOwner(wep);
			if ( IsValidClient(client) ) {
				int slot = GetSlotFromWeapon(client, wep);
				if (slot not_eq -1 and slot < 3) flDviqa[client][slot] = GetGameTime();
				AmmoTable[wep] = GetWeaponAmmo(wep);
				ClipTable[wep] = GetWeaponClip(wep);
			}
		}
	}
	return Plugin_Continue;
}

public void OnWeaponSwitchPost(int client, int weapon)
{
	if ( not cvPluginEnabled.BoolValue ) {
		return;
	}
	static int iActiveSlot[KULEH];
	if ( IsClientValid(client) and IsValidEntity(weapon) ) {
		switch (iActiveSlot[client]) // This will be the previous slot at this time, that you switched FROM
		{
			case 0, 1: flDviqa[client][iActiveSlot[client]] = GetGameTime();
		}
		iActiveSlot[client] = GetSlotFromWeapon(client, weapon);
	}
	return;
}
public Action CommandTemplate(int client, int args)
{
	if (not bChatSpam[client]) bChatSpam[client] = true;
	else bChatSpam[client] = false;
	return Plugin_Handled;
}
public Action CommandReload(int client, int args)
{
	cvSound.GetString( strSound, sizeof(strSound) );
	PrecacheSound(strSound, true);
	SetupKeyValues();
	return Plugin_Handled;
}
stock void BackPackReload(int weapref, float &flHolsterTime, float flSecondsDelay, bool SingleReload = false, int ReloadInterval = 1)
{
	int weapon = EntRefToEntIndex(weapref);
	if ( weapon <= 0 ) return;

	int client = GetOwner(weapon);
	if (client <= 0 or not IsPlayerAlive(client) or flSecondsDelay >= 100.0)
		return;

	if (bChatSpam[client]) {
		PrintToConsole(client, "got past weapon and client checks");
	}
	if ( (GetGameTime()-flHolsterTime) > flSecondsDelay )
	{
		flHolsterTime = GetGameTime();
		if (GetWeaponClip(weapon) < ClipTable[weapon])
		{
			if (SingleReload)
			{
				if ( ClipTable[weapon]-GetWeaponClip(weapon) < ReloadInterval )
				{
					ReloadInterval = ClipTable[weapon]-GetWeaponClip(weapon);
				}
				if (GetWeaponAmmo(weapon) < ReloadInterval) ReloadInterval = GetWeaponAmmo(weapon);
				if (ReloadInterval < 1) return;

				SetWeaponClip(weapon, GetWeaponClip(weapon)+ReloadInterval);
				SetWeaponAmmo(weapon, GetWeaponAmmo(weapon)-ReloadInterval);
				if (bChatSpam[client]) {
					PrintToConsole(client, "did single reload");
				}
				EmitSoundToClient(client, strSound);
				EmitSoundToClient(client, strSound);
			}
			else
			{
				ReloadInterval = ClipTable[weapon]-GetWeaponClip(weapon);
				if (GetWeaponAmmo(weapon) < ReloadInterval) ReloadInterval = GetWeaponAmmo(weapon);
				if (ReloadInterval < 1) return;

				SetWeaponClip(weapon, GetWeaponClip(weapon)+ReloadInterval);
				SetWeaponAmmo(weapon, GetWeaponAmmo(weapon)-ReloadInterval);
				if (bChatSpam[client]) {
					PrintToConsole(client, "did mag reload");
				}
				EmitSoundToClient(client, strSound);
				EmitSoundToClient(client, strSound);
			}
		}
	}
	return;
}
void SetupKeyValues()
{
	char strBuffer[URKHA];

	// Create key values object and parse file.
	BuildPath(Path_SM, strBuffer, sizeof(strBuffer), "configs/holster-reload.txt");
	KeyValues kvDict = new KeyValues("HolsterReload");

	if (FileToKeyValues(kvDict, strBuffer) eq false) {
		SetFailState("Error, can't read file containing the holster-reload list: %s", strBuffer);
	}

	kvDict.GotoFirstSubKey();
	LazyGlobal[1][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[1][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[1][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[2][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[2][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[2][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[3][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[3][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[3][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[4][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[4][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[4][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[5][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[5][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[5][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[6][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[6][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[6][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[7][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[7][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[7][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[8][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[8][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[8][2] = kvDict.GetNum("reload_interval");

	kvDict.GotoNextKey();
	LazyGlobal[9][0] = kvDict.GetFloat("reload_time");
	LazyGlobal[9][1] = kvDict.GetNum("single_or_all_reload");
	LazyGlobal[9][2] = kvDict.GetNum("reload_interval");

	delete kvDict;
}
stock int GetOwner(int entity)
{
	if (IsValidEdict(entity) and IsValidEntity(entity)) {
		return GetEntPropEnt(entity, Prop_Send, "m_hOwnerEntity");
	}
	return -1;
}
stock int GetActiveWeap(int entity)
{
	if (IsValidEdict(entity) and IsValidEntity(entity)) {
		return GetEntPropEnt(entity, Prop_Send, "m_hActiveWeapon");
	}
	return -1;
}
stock int GetSlotFromWeapon(int client, int wep)
{
	for (int i = 0; i < 5; i++) {
		if ( wep eq GetPlayerWeaponSlot(client, i) ) return i;
	}
	return -1;
}
stock int GetWeaponAmmo(int weapon)
{
	int owner = GetOwner(weapon);
	if (owner <= 0)
		return 0;

	if (IsValidEntity(weapon))
	{
		int iOffset = GetEntProp(weapon, Prop_Send, "m_iPrimaryAmmoType", 1)*4;
		int iAmmoTable = FindSendPropInfo("CTFPlayer", "m_iAmmo");
		return GetEntData(owner, iAmmoTable+iOffset, 4);
	}
	return 0;
}

stock int GetWeaponClip(int weapon)
{
	if (IsValidEntity(weapon))
	{
		int AmmoClipTable = FindSendPropInfo("CTFWeaponBase", "m_iClip1");
		return GetEntData(weapon, AmmoClipTable);
	}
	return 0;
}
stock void SetWeaponAmmo(int weapon, int ammo)
{
	int owner = GetOwner(weapon);
	if (owner <= 0)
		return;

	if (IsValidEntity(weapon))
	{
		int iOffset = GetEntProp(weapon, Prop_Send, "m_iPrimaryAmmoType", 1)*4;
		int iAmmoTable = FindSendPropInfo("CTFPlayer", "m_iAmmo");
		SetEntData(owner, iAmmoTable+iOffset, ammo, 4, true);
	}
	return;
}
stock void SetWeaponClip(int weapon, int ammo)
{
	if (IsValidEntity(weapon))
	{
		int iAmmoTable = FindSendPropInfo("CTFWeaponBase", "m_iClip1");
		SetEntData(weapon, iAmmoTable, ammo, 4, true);
	}
}
/*stock int GetItemID(int item)
{
	if ( IsValidEdict(item) ) {
		return GetEntProp(item, Prop_Send, "m_iItemDefinitionIndex");
	}
	return -1;
}*/
stock void CheckDownload(char[] dlpath)
{
	if ( FileExists(dlpath) ) AddFileToDownloadsTable(dlpath);
}
stock bool IsValidClient(int client, bool replaycheck = true)
{
	if ( not IsClientValid(client) ) return false;
	if ( not IsClientInGame(client) ) return false;
	if ( GetEntProp(client, Prop_Send, "m_bIsCoaching") ) return false;
	if ( replaycheck ) if ( IsClientSourceTV(client) or IsClientReplay(client) ) return false;
	return true;
}